<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <script
      src="https://kit.fontawesome.com/343a20c5e6.js"
      crossorigin="anonymous"
    ></script>
    <link
      rel="stylesheet"
      type="text/css"
      href="https://miro.com/app/static/miro.uikit.css"
    />
    <script src="https://miro.com/app/static/sdk.1.1.js"></script>
    <link
      href="//cdn.muicss.com/mui-0.10.3/css/mui.min.css"
      rel="stylesheet"
      type="text/css"
    />
    <script src="//cdn.muicss.com/mui-0.10.3/js/mui.min.js"></script>

    <style>
      body {
        margin: 0;
        padding: 0;
      }

      .widget-info {
        padding: 20px 24px 8em 24px;
        height: 100%;
      }

      .editor {
        width: 310px;
        height: calc(100% - 120px);
        border: 1px solid #ccc;
        padding: 10px;
        box-sizing: border-box;
        font-family: Arial;
        font-size: 14px;
        margin: 0 -10px;
        resize: none;
      }
      .bottom_navi {
        text-align: right;
        background: white;
        position: fixed;
        box-sizing: border-box;
        padding: 2em;
        margin: 0;
        width: 100%;
        height: 7em;
        bottom: 0;
        display: flex;
        flex-direction: row;
        justify-items: stretch;
      }
    </style>
  </head>

  <body>
    <!--
<div class="rtb-sidebar-caption">Extra notes</div>
<div class="no-selected-widget">
    Please select one widget <br>to add notes ✏️
</div>
-->
    <div class="widget-info">
      <h1 id="step_head"></h1>
      <div id="step_text"></div>
      <!--
    <p id="widget-name"></p>
    <textarea placeholder="Add some notes here. Saves locally" id="editor" class="editor">text word</textarea>
    --></div>
    <div class="bottom_navi">
      <div style="position: absolute" id="step_number"></div>
      <button
        class="mui-btn mui-btn--secondary mui-btn--raised"
        style="padding-left: 0.8em; padding-right: 0.8em"
        onclick="stepBackward(true)"
      >
        <i class="fas fa-backward"></i>
      </button>
      <button
        class="mui-btn mui-btn--secondary mui-btn--raised"
        style="padding-left: 0.8em; padding-right: 0.8em"
        onclick="stepBackward()"
      >
        <i class="fas fa-step-backward"></i>
      </button>
      <button
        class="mui-btn mui-btn--primary mui-btn--raised"
        style="flex-grow: 1"
        onclick="stepForward()"
      >
        Eteenpäin &nbsp;<i class="fas fa-play"></i>
      </button>
      <button
        class="mui-btn mui-btn--secondary mui-btn--raised"
        style="padding-left: 0.8em; padding-right: 0.8em"
        onclick="stepForward(true)"
      >
        <i class="fas fa-forward"></i>
      </button>
    </div>
    <script>
      var MiroEnabled = () => true; // () => miro && miro.board;
      var StepNumber = 0;
      const SHARED_STEP = "Step";

      const stepData = [
        {
          title: "Tervetuloa Skenaariopeliin!",
          cuePoint: true,
          body: `
Skenaariopelissä ryhmällenne on annettu kaikki valta luotsata itsenne seuraavien vuosien tai vuosikymmenten halki.

Seuraavan noin 90 minuutin aikana luodaan 2–5 hengen ryhmässä yksi mahdollinen tulevaisuusskenaario ryhmäänne kiinnostavasta aiheesta. Lopuksi joku ryhmästänne kertoo siitä 2 minuutin kiteytetyn tarinan, joka kannattaa tallentaa muistoksi.

Suosittelemme, että ryhmä valitsee aluksi keskuudestaan pelinjohtajan, joka huolehtii pelin etenemisestä.

Painakaa <b>Eteenpäin <i class="fas fa-play"></i></b> -nappia kun olette valmiita aloittamaan!

Pelissä käytetään Miron virtuaalisia tarralappuja. Odotellessa voit tutustua Miron esittelyvideoon tai harjoitella <b><i class="far fa-sticky-note"></i> tarralappujen</b> vetämistä työkalupakista taululle.

<iframe width="200" height="150" src="https://www.youtube.com/embed/7L1-0DOGHDY" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

`,
        },

        {
          title: "1/6 Me ja skenaarion luonne",
          cuePoint: true,
          body: `
Kirjoittakaa aluksi <b>lapulle <i class="far fa-sticky-note"></i></b>, kenen näkökulmasta tulevaisuutta tarkastelette.

<i>esim. “Yle".</i>
`,
        },

        {
          title: "1/6 Me ja skenaarion luonne",
          body: `
Kirjoittakaa kortille <i class="far fa-sticky-note"></i> skenaarionne tarkasteluvuosi.

<i>esim. "2030" tai "2050"</i>
`,
        },

        {
          title: "1/6 Me ja skenaarion luonne",
          body: `
Kirjoittakaa kortille <i class="far fa-sticky-note"></i>, minkä luonteisen skenaarion laaditte.

<i>esim. toivottava/epätoivottava, todennäköinen/epätodennäköinen</i>
`,
        },

        {
          title: "2/6 Maailma vuonna {scenario_year}",
          cuePoint: true,
          body: `

<b>Tutustu</b> hetki pöydällä oleviin, tulevaisuutta muokkaaviin ilmiöihin.

<b><i class="fas fa-mouse-pointer"></i> Osoita</b> sitten ilmiötä, joka on ollut vaikuttavin vuoden {scenario_year} maailmassa.

<b>Siivotkaa</b> pöydältä ne ilmiöt, jotka eivät tulleet valituksi.

<b>Eteenpäin <i class="fas fa-play"></i></b> -nappi jakaa valittavaksi uusia ilmiöitä, kunnes pöydällä on 5 valittua ilmiötä.
`,
        },

        {
          title: "3/6 {scenario_actor} vuonna {scenario_year}",
          cuePoint: true,
          body: `
<b><i class="far fa-sticky-note"></i> Kirjoita</b> omalle kortille yksi olennainen ominaisuus, jolla {scenario_actor} on sopeutunut vuoden {scenario_year} maailmaan.
<i>Aloita vaikkapa "{scenario_actor} on..."</i>

<b>Esitelkää</b> vuorollanne omat ehdotuksenne muille.
`,
        },

        {
          title: "3/6 {scenario_actor} vuonna {scenario_year}",
          body: `
<b><i class="far fa-sticky-note"></i> Kirjoita</b> uudelle kortille vielä yksi lisäominaisuus. Voit yhdistellä tai kehitellä jotain ehdotettua ominaisuutta!

<b>Esitelkää</b> vuorollanne myös nämä ehdotukset.
`,
        },

        {
          title: "3/6 {scenario_actor} vuonna {scenario_year}",
          body: `
<b><i class="fas fa-mouse-pointer"></i> Osoita</b> ominaisuutta, joka on mielestäsi olennaisin ja skenaarion luonteen mukainen.

<b>Keskustelkaa</b> valinnoista ja jättäkää pöydälle 3 ominaisuutta. Muokatkaa ja yhdistäkää ominaisuuksia tarvittaessa.
`,
        },

        {
          title: "4/6 Miten tähän päädyttiin?",
          cuePoint: true,
          body: `
Eletään vuotta {scenario_year}. Seuraavaksi muistellaan, mitkä aiemmat tapahtumat ovat johtaneet siihen, millainen {scenario_actor} on nyt.

<b><i class="far fa-sticky-note"></i> Kirjoita</b> kortille jokin kiinnostava kehityskulku vuoden {backcast_year_4} paikkeilta, joka vaikutti jonkin ominaisuuden kehittymiseen.

<b>Esitelkää</b> vuorollanne tapahtumat muille.

<b><i class="fas fa-mouse-pointer"></i> Osoita</b> sitten tapahtumaa, joka parhaiten selittää tulevan kehityksen.

<b>Asetelkaa</b> nämä tapahtumat ne aikajanalle ja siirtäkää muut sivuun.
`,
        },

        {
          title: "4/6 Miten tähän päädyttiin?",
          cuePoint: false,
          body: `
<b><i class="far fa-sticky-note"></i> Kirjoita</b> kortille jokin kiinnostava kehityskulku vuoden {backcast_year_3} paikkeilta, joka vaikutti jonkin ominaisuuden kehittymiseen.

<b>Esitelkää</b> vuorollanne tapahtumat muille.

<b><i class="fas fa-mouse-pointer"></i> Osoita</b> sitten tapahtumaa, joka parhaiten selittää tulevan kehityksen.

<b>Asetelkaa</b> nämä tapahtumat ne aikajanalle ja siirtäkää muut sivuun.
`,
        },

        {
          title: "4/6 Miten tähän päädyttiin?",
          cuePoint: false,
          body: `
<b><i class="far fa-sticky-note"></i> Kirjoita</b> kortille jokin kiinnostava kehityskulku vuoden {backcast_year_2} paikkeilta, joka vaikutti jonkin ominaisuuden kehittymiseen.

<b>Esitelkää</b> vuorollanne tapahtumat muille.

<b><i class="fas fa-mouse-pointer"></i> Osoita</b> sitten tapahtumaa, joka parhaiten selittää tulevan kehityksen.

<b>Asetelkaa</b> nämä tapahtumat ne aikajanalle ja siirtäkää muut sivuun.
`,
        },

        {
          title: "4/6 Miten tähän päädyttiin?",
          cuePoint: false,
          body: `
<b><i class="far fa-sticky-note"></i> Kirjoita</b> kortille jokin kiinnostava kehityskulku vuoden {backcast_year_1} paikkeilta, joka vaikutti jonkin ominaisuuden kehittymiseen.

<b>Esitelkää</b> vuorollanne tapahtumat muille.

<b><i class="fas fa-mouse-pointer"></i> Osoita</b> sitten tapahtumaa, joka parhaiten selittää tulevan kehityksen.

<b>Asetelkaa</b> nämä tapahtumat ne aikajanalle ja siirtäkää muut sivuun.
`,
        },

        {
          title: "5/6 Dokumentoi",
          cuePoint: true,
          body: `
Valmistelkaa ja kertokaa 2 minuutin tarina tulevaisuuden maailmasta, itsestänne siellä sekä kohokohdat tapahtumista, jotka siihen johtivat.

<i>Vinkki: Tarinan dokumentoimiseen voi käyttää vaikkapa videopuhelun tallennustoimintoa [Ohjeita].</i>
`,
        },

        {
          title: "6/6 Jaa ja keskustele",
          cuePoint: true,
          body: `
Käyttäkää pieni hetki keskusteluun pelin tuloksista.

<b>Kerro</b> vuorollasi muille, mikä yllätti, mikä energisoi, mikä ehkä säikäytti. Minkä ajatuksen kanssa haluaisit edetä pelin jälkeen, miten ja kenen kanssa.

Kiitoksia pelistä!
`,
        },
      ];
      var replacements = {
        "{scenario_actor}": "Yle",
        "{scenario_year}": "2030",
        "{backcast_year_4}": "2029",
        "{backcast_year_3}": "2027",
        "{backcast_year_2}": "2023",
        "{backcast_year_1}": "2021",
      };

      changeState(StepNumber);

      miro.onReady(async () => {
        initialize();
        // Below: Spawn authorization dialog
        /*
        const authorized = await miro.isAuthorized();
        if (authorized) {
            initialize();
        } else {
            miro.board.ui.openModal('skenaariopeli/not-authorized.html')
                .then(res => {
                    if (res === 'success') {
                        initialize();
                    }
                })
        }
        */
      });

      async function initialize() {
        StepNumber = parseInt(await getSharedValue(SHARED_STEP));
        changeState(StepNumber);

        var poll = setInterval(pollCallback, 2000);
        // clearInterval(poll)
      }

      async function stepForward(skipToCue) {
        let stop = false;
        while (StepNumber < stepData.length - 1 && !stop) {
          if (MiroEnabled()) {
            await onExitState(StepNumber);
          }
          StepNumber++;
          if (!skipToCue || stepData[StepNumber].cuePoint) stop = true;
        }
        changeState(StepNumber);
        if (MiroEnabled) setSharedValue(SHARED_STEP, StepNumber);
      }

      async function stepBackward(skipToCue) {
        let stop = false;
        while (StepNumber > 0 && !stop) {
          if (MiroEnabled()) {
            await onExitState(StepNumber);
          }
          StepNumber--;
          if (!skipToCue || stepData[StepNumber].cuePoint) stop = true;
        }
        changeState(StepNumber);
        if (MiroEnabled) setSharedValue(SHARED_STEP, StepNumber);
      }

      function formatPlainText(text) {
        var formattedText = text;
        // use string replacements
        formattedText = Object.keys(replacements).reduce(
          (prev, key) => prev.replace(new RegExp(key, "g"), replacements[key]),
          formattedText
        );
        // add html paragraph breaks
        formattedText = formattedText.replace(
          /^(?!<p>)(.*)(?!<\/p>)$/gm,
          "<p>$1</p>"
        );
        return formattedText;
      }

      function changeState(stateId) {
        var stateData = stepData[stateId];

        document.getElementById("step_number").innerHTML = StepNumber;
        document.getElementById("step_head").innerHTML = formatPlainText(
          stateData.title
        );
        document.getElementById("step_text").innerHTML = formatPlainText(
          stateData.body
        );
      }

      async function pollCallback() {
        let sharedState = parseInt(await getSharedValue(SHARED_STEP));
        if (StepNumber != sharedState) {
          StepNumber = sharedState;
          changeState(StepNumber);
        }
      }

      async function onExitState(state) {
        let actorResponse = await getContainedStickerText(
          "SCENARIO_ACTOR_CONTAINER"
        );
        if (actorResponse.success) {
          replacements["{scenario_actor}"] = actorResponse.value;
        }
        let yearResponse = await getContainedStickerText(
          "SCENARIO_YEAR_CONTAINER"
        );
        if (yearResponse.success) {
          replacements["{scenario_year}"] = yearResponse.value;
        }
        console.log("Actor: " + actorResponse.value);
        console.log("Year: " + yearResponse.value);
      }

      // Get a Miro Sticker to store sync data in
      async function getMiroStickerByKey(key) {
        var searchString = `${key}: `;
        var elements = await miro.board.widgets.get({
          type: "sticker",
        });
        var element = elements.find((candidate) =>
          candidate.plainText.startsWith(searchString)
        );
        // miro.board.widgets.update([{ id: element.id, clientVisible: false}])
        return element;
      }

      // Fetch value for key from a Miro Sticker
      async function getSharedValue(key) {
        let element = await getMiroStickerByKey(key);
        if (element) {
          return await element.plainText.substring(key.length + 2); // Skip key name and ": "
        } else {
          return undefined;
        }
      }

      // Store value for key from a Sticker
      async function setSharedValue(key, value) {
        let element = await getMiroStickerByKey(key);
        let text = `${key}: ${value}`;
        if (element) {
          await miro.board.widgets.update([{ id: element.id, text: text }]);
        } else {
          await miro.board.widgets.create([
            { type: "sticker", text: text /* clientVisible: false, */ },
          ]);
        }
      }

      async function getMiroElementByContent(key) {
        return (await miro.board.widgets.get({ plainText: key }))[0];
      }

      async function getIntersectedStickers(container) {
        let stickers = await miro.board.widgets.get({
          type: "sticker",
        });
        let elements = stickers.filter((sticker) => {
          if (sticker.bounds.right < container.bounds.left) return false;
          if (sticker.bounds.left > container.bounds.right) return false;
          if (sticker.bounds.bottom < container.bounds.top) return false;
          if (sticker.bounds.top > container.bounds.bottom) return false;
          return true;
        });
        return elements;
      }

      // Expect just one sticker
      async function getContainedStickerText(containerContent) {
        let container = await getMiroElementByContent(containerContent);
        if (!container) {
          let response = {
            success: false,
            errorMessage: `Aluetta nimeltä ${containerContent} ei löytynyt.`,
          };
          console.warn(response.errorMessage);
          return response;
        }

        let containedStickers = await getIntersectedStickers(container);
        if (containedStickers.length < 1) {
          let response = {
            success: false,
            errorMessage: `Yhtään tarralappua ei löytynyt alueella ${container.plainText}`,
          };
          console.warn(response.errorMessage);
          return response;
        }
        if (containedStickers.length > 1) {
          let response = {
            success: false,
            errorMessage: `Useita tarralappuja löydettiin alueella ${container.plainText}`,
          };
          console.warn(response.errorMessage);
          return response;
        }
        let response = {
          success: true,
          value: containedStickers[0].plainText,
        };
        return response;
      }

      /*
	let lastSelectedWidgetId
	let widgetName = document.querySelector('#widget-name')
	let widgetInfo = document.querySelector('.widget-info')
	let editor = document.querySelector('#editor')
	let placeholder = document.querySelector('.no-selected-widget')

	function onSelectionChange(e) {
		let selectedWidgets = e.data
		updateSelection(selectedWidgets)
	}

	function updateSelection(selectedWidgets) {
		let selectedWidget = selectedWidgets[0]
		if (selectedWidgets.length === 1) {
			showElement(widgetInfo)
			hideElement(placeholder)
			saveEditorData()
			lastSelectedWidgetId = selectedWidget.id
			widgetName.innerText = selectedWidget.type
			editor.value = getData(lastSelectedWidgetId)
		} else {
			showElement(placeholder)
			hideElement(widgetInfo)
		}
	}

	function showElement(el) {
		el.style.display = 'block'
	}

	function hideElement(el) {
		el.style.display = 'none'
	}

	hideElement(placeholder)
	hideElement(widgetInfo)

	miro.onReady(() => {
		miro.addListener(miro.enums.event.SELECTION_UPDATED, onSelectionChange)
		miro.board.selection.get().then((selectedWidgets) => {
			updateSelection(selectedWidgets)
		})
	})

	editor.addEventListener('change', saveEditorData)

	async function saveEditorData() {
		if (lastSelectedWidgetId) {
			saveData(lastSelectedWidgetId, editor.value)
			lastSelectedWidgetId = undefined
		}
	}

	const LS_KEY = 'rtb-plugin-widget-info'

	function saveData(widgetId, text) {
		let data = JSON.parse(localStorage.getItem(LS_KEY)) || {}
		data[widgetId] = text
		localStorage.setItem(LS_KEY, JSON.stringify(data))
	}

	function getData(widgetId) {
		let data = JSON.parse(localStorage.getItem(LS_KEY)) || {}
		return data[widgetId] || ''
	}
*/
    </script>
  </body>
</html>
